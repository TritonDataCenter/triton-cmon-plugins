#!/usr/bin/env bash

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

# Copyright 2025 Edgecast Cloud LLC.

set -o errexit
set -o pipefail

# shellcheck disable=SC2154
if [[ -n "$TRACE" ]]; then
    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -o xtrace
fi

# Get list of zones with all needed fields in parseable format
zone_list=$(vmadm list -p -o uuid,alias,brand,state,ram,vcpus,quota,flexible_disk_size,max_swap,max_lwps,billing_id,owner_uuid 2>/dev/null || true)

# shellcheck disable=SC2181
if [ -z "$zone_list" ]; then
    # If vmadm fails or no zones, exit silently
    exit 0
fi

# Set TTL to 300 seconds (5 minutes) since vmadm operations are expensive
printf '# OPTION ttl 300\n'

# Initialize counters for zone counts by brand and state
declare -A zone_counts

# Track zone info and allocation metrics
zone_info_lines=""
zone_memory_lines=""
zone_vcpus_lines=""
zone_disk_lines=""
zone_flexible_disk_lines=""
zone_swap_lines=""
zone_lwps_lines=""

# Process each zone (vmadm list -p outputs colon-separated fields)
while IFS=: read -r uuid alias brand state ram vcpus quota flexible_disk max_swap max_lwps billing_id owner_uuid; do
    # Handle empty/null values
    [ -z "$alias" ] && alias=""
    [ -z "$billing_id" ] && billing_id=""
    [ -z "$owner_uuid" ] && owner_uuid=""
    [ -z "$ram" ] && ram="0"
    [ -z "$vcpus" ] && vcpus="0"
    [ -z "$quota" ] && quota="0"
    [ -z "$flexible_disk" ] && flexible_disk="0"
    [ -z "$max_swap" ] && max_swap="0"
    [ -z "$max_lwps" ] && max_lwps="0"

    # Count zones by brand and state
    key="${brand},${state}"
    if [ -z "${zone_counts[$key]}" ]; then
        zone_counts[$key]=0
    fi
    zone_counts[$key]=$((zone_counts[$key] + 1))

    # Build per-zone allocation metrics
    # RAM is in MiB, convert to bytes
    if [ "$ram" != "0" ]; then
        ram_bytes=$((ram * 1048576))
        zone_memory_lines="${zone_memory_lines}cn_zone_allocated_memory_bytes{uuid=\"${uuid}\"}\t${ram_bytes}\n"
    fi

    # VCPUs
    if [ "$vcpus" != "0" ]; then
        zone_vcpus_lines="${zone_vcpus_lines}cn_zone_allocated_vcpus{uuid=\"${uuid}\"}\t${vcpus}\n"
    fi

    # Quota is in GiB, convert to bytes
    if [ "$quota" != "0" ]; then
        quota_bytes=$((quota * 1073741824))
        zone_disk_lines="${zone_disk_lines}cn_zone_allocated_disk_bytes{uuid=\"${uuid}\"}\t${quota_bytes}\n"
    fi

    # Flexible disk size is in MiB, convert to bytes
    if [ "$flexible_disk" != "0" ]; then
        flexible_disk_bytes=$((flexible_disk * 1048576))
        zone_flexible_disk_lines="${zone_flexible_disk_lines}cn_zone_allocated_flexible_disk_bytes{uuid=\"${uuid}\"}\t${flexible_disk_bytes}\n"
    fi

    # Max swap is in MiB, convert to bytes
    if [ "$max_swap" != "0" ]; then
        max_swap_bytes=$((max_swap * 1048576))
        zone_swap_lines="${zone_swap_lines}cn_zone_allocated_swap_bytes{uuid=\"${uuid}\"}\t${max_swap_bytes}\n"
    fi

    # Max lwps
    if [ "$max_lwps" != "0" ]; then
        zone_lwps_lines="${zone_lwps_lines}cn_zone_allocated_max_lwps{uuid=\"${uuid}\"}\t${max_lwps}\n"
    fi

    # Build zone info line
    zone_info_lines="${zone_info_lines}cn_zone_info{uuid=\"${uuid}\",alias=\"${alias}\",brand=\"${brand}\",billing_id=\"${billing_id}\",owner_uuid=\"${owner_uuid}\"}\t1\n"
done <<< "$zone_list"

# Output zone count metrics by brand and state
# Include all possible states (even with 0 count) for consistent time series
printf '# HELP cn_zone_state Number of zones by brand and state\n'
printf '# TYPE cn_zone_state gauge\n'

# All possible zone brands and states
brands=("bhyve" "joyent" "lx" "kvm")
states=("configured" "down" "failed" "incomplete" "installed" "provisioning" "ready" "receiving" "running" "shutting_down" "stopped" "stopping")

# Output all brand/state combinations
for brand in "${brands[@]}"; do
    for state in "${states[@]}"; do
        key="${brand},${state}"
        count="${zone_counts[$key]:-0}"
        printf 'cn_zone_state{brand="%s",state="%s"}\t%d\n' "$brand" "$state" "$count"
    done
done

# Output per-zone allocation metrics
printf '# HELP cn_zone_allocated_memory_bytes Memory allocated to zone in bytes\n'
printf '# TYPE cn_zone_allocated_memory_bytes gauge\n'
printf '%b' "$zone_memory_lines"

printf '# HELP cn_zone_allocated_vcpus vCPUs allocated to zone\n'
printf '# TYPE cn_zone_allocated_vcpus gauge\n'
printf '%b' "$zone_vcpus_lines"

printf '# HELP cn_zone_allocated_disk_bytes Disk quota allocated to zone in bytes\n'
printf '# TYPE cn_zone_allocated_disk_bytes gauge\n'
printf '%b' "$zone_disk_lines"

printf '# HELP cn_zone_allocated_flexible_disk_bytes Flexible disk size allocated to zone in bytes\n'
printf '# TYPE cn_zone_allocated_flexible_disk_bytes gauge\n'
printf '%b' "$zone_flexible_disk_lines"

printf '# HELP cn_zone_allocated_swap_bytes Swap allocated to zone in bytes\n'
printf '# TYPE cn_zone_allocated_swap_bytes gauge\n'
printf '%b' "$zone_swap_lines"

printf '# HELP cn_zone_allocated_max_lwps Max lightweight processes allocated to zone\n'
printf '# TYPE cn_zone_allocated_max_lwps gauge\n'
printf '%b' "$zone_lwps_lines"

# Output zone info metrics
printf '# HELP cn_zone_info Zone information with labels\n'
printf '# TYPE cn_zone_info gauge\n'
printf '%b' "$zone_info_lines"
